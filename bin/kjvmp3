#!/usr/bin/perl

# KVJ audio player for emacs kjv-mode, by twitham@sbcglobal.net

# can also now generate .lrc lyric files for mythmusic!

# Downloaded from https://www.audiotreasure.com/indexKJV.htm in 2022:
my $cache = '/var/lib/mythtv/music/iTunes/iTunes Media/Podcasts/KJV';

# converted from Sword by ~twitham/bin/kjv gen 1-2000 > kjv.txt in 2022:
my $kjv = 'zcat /home/twitham/kjv.txt.gz |';

use warnings;
use strict;
use Getopt::Long;
use Lingua::EN::Syllable;
use Time::Local;
use POSIX qw(strftime);

my %opt = (mp3 => $cache, kjv => $kjv); # defaults

GetOptions(\%opt, qw(mp3|m=s lyric|l kjv|t=s verbose|v words|w n|dry
read|r=i a=s))
    or die "usage: $0 [options] '<book> Chapter <num>'
-m | --mp3	location of mp3 files ($opt{mp3})
-l |--lyric	generate .lrc lyric files instead, from:
-t | --kjv	location of KJV text ($opt{kjv}), for -l
-v | --verbose	show syllables per line with -l, reading stats with -r
-w | --words	show syllables per word with -l
-n | --dry	don't write .lrc with -l, useful with -v -s
-r | --read = N	generate daily reading schedule for N days
-a <-r file>	annotate reading schedule into listed files
";

chdir $cache or die $!;

binmode STDOUT, ":encoding(UTF-8)";

opendir DIR, '.' or die $!;
my @mp3 = sort grep /^\d+_/, readdir DIR;
closedir DIR;

if ($opt{lyric}) {		# generate lyric files for mythmusic!

    &lyrics;

} elsif ($opt{read}) {	  # generate time-based daily reading schedule

    &readplan;

} elsif ($opt{a}) {		# add reading schedule to each file

    &annotate;

} elsif (@ARGV and $ARGV[0] =~ /(.+) Chapter (\d+)/) { # original purpose: audio player

    &play($1, $2);

}

sub file {			# book/chapter -> .mp3 filename
    my($book, $chapter) = @_;
    $book =~ s/ /_/g;
    $book =~ s/^III_/3/ or $book =~ s/^II_/2/ or  $book =~ s/^I_/1/;
    $book =~ s/_of_John//;
    my $chap = sprintf "%s%03d", $book, $chapter;
    my $file = (grep /$chap.mp3/, @mp3)[0] || (grep /$book.mp3/, @mp3)[0] || 0;
    return $file;
}

sub play {
    my $file = file(@_);
    $file or return;
    system qw/mplayer -quiet/, $file;
}

# This measures the text for distributing the correct portion of time
# of the audio to each line.  Initialy I measured bytes, then improved
# to words, and finally to syllables.

sub len {			# return the length of the text
    my $len = 0;
    for my $line (@_) {
	$line =~ /^(\S+ \d+:\d+:)?\s*(.*)/; # ignore chapter/verse leader

	(my $text = $2) =~ s/([;:,])/ PAUSE /g; # punctuation pauses
	$text =~ s/([?.])/ STOP STOP /g;	# sentence pauses

	$text =~ s/\W+/ /g; # strip italics and quotes and break hyphens

	$text =~ s/^\s*$/ P /;	# blank lines need a unique timestamp

	for my $word (split /\s+/, $text) {
	    $word =~ /^\w+$/ or next;
	    my $one = syllable $word;
	    print " $word=$one" if $opt{words};
	    $len += $one;
	}
	print "\n" if $opt{words};
    }
    return $len;
}

sub lyrics {
    my @line;
    open FILE, $kjv or die "$kjv: $!";
    while (<FILE>) {
	next if / mode: kjv /;	# skip header
	s/\(KJV\)//;		# skip footer
	s/\s+\*\*\*.*//;	# skip reading schedule
	if (/\{ (The Book of .+|.+ Chapter \d+) \}/) {
	    &lyric(\@line) and @line = ();
	}
	push @line, $_;
    }
    &lyric(\@line);
}

# See https://en.wikipedia.org/wiki/LRC_(file_format)
sub lyric {
    my($lineref) = @_;
    my $head = (grep { /\{ .+ Chapter \d+ \}/ } @$lineref)[0] or return;
    $head =~ /\{ (.+) Chapter (\d+) \}/ or return;
    grep { $head =~ /$_/ } @ARGV or return 1 if @ARGV;
    my($book, $chap) = ($1, $2);
    my $file = file($book, $chap);
    $file or warn "no file in $head\n" and return;
    my $duration = `exiftool -duration $file`;
    my($h, $m, $s) = ($duration =~ /: (\d+):(\d+):(\d+)/);
    defined $s or ($h, $m, $s) = ($duration =~ /: ()()(\d+\.\d+) s/);
    defined $s or warn "unknown seconds in $file\n" and return;
    $duration = ($h || 0) * 3600 + ($m || 0) * 60 + $s;
    my $len = len(@$lineref);
    my $per = $duration / $len;	# seconds per word of text
    my $t = 0;
    (my $out = $file) =~ s/.mp3/.lrc/;
    open OUT, '>', ($opt{n} ? '/dev/null' : $out) or die $!;
    for my $line (@$lineref) {
	my $min = int($t / 60);
	my $sec = $t - $min * 60;
	my $this = sprintf "[%02d:%05.02f]$line", $min, $sec;
	print OUT $this;
	my $len = len($line);
	print "$len\t$this" if $opt{verbose};
	$t += $len * $per;
    }
    printf "%4d seconds in %4d lines in $out\t(%.5f)\n",
	$duration, scalar @$lineref, $per;
    return 1;
}

sub readplan { # generate time-based reading schedule from lrc.log and  *.lrc
    my $sec = 0;
    my %sec;
    open FILE, 'lrc.log' or die $!; # output from -l, required
    while (<FILE>) {
	/(\d+) seconds .* (\w+.lrc)/ and $sec += $1
	    and $sec{$2} = $1;
    }
    my %time;
    my $time = my $this = my $last = 0;
    for my $lrc (<*.lrc>) {
	open FILE, '<:encoding(UTF-8)', $lrc or die $!;
	while (<FILE>) {
	    chomp;
	    /(\d{2}):(\d{2}.\d{2})/
		and $this = $1 * 60 + $2;
	    /(\{ .+ Chapter \d+ \})/ and $time{$1} = $time + $this;
	}
	$time += $sec{$lrc} || 0;
    }
    $time{'{ The End Chapter 0 }'} = $time;
    $time = $last = 0;
    my $date = timelocal(0, 0, 12, 1, 0, 3); # 1973 - 1975 no leap years
    my $days = $opt{read} > 30 ? $opt{read} : 365;
    my $one = $sec / $days;
    my $i = my $delta = my $max = 0;
    my $min = 999999;
    for (my $time = $one; $time <= $sec; $time += $one) {

	my $goal = $last + $one; # daily reading goal, but:
	$goal -= 0.3 * $delta;	 # move toward staying on-time
	my $chap = (sort { abs($time{$a} - $goal) <=>
			       abs($time{$b} - $goal) } keys %time)[0];
	my $this = $time{$chap};
	$delta = $this - $time;	# offset from perfect time
	my $len = $this - $last; # today's reading time
	$max = $len if $len > $max;
	$min = $len if $len < $min;

	$i++;
	my $ts = strftime "%10B %e", localtime $date;
	if ($opt{verbose}) {
	    printf "%d\t%3d/%3d\t%s\t%d\t%s\n", $len, $i, $days,
		$ts, $delta, $chap;
	} else {
	    printf "%s\t%s\n", $ts, $chap;
	}
	$last = $this;
	$date += 24 * 60 * 60;
    }
    printf "(goal=%.0f seconds for $days days, %d-%d=%d, +/-=delta)\n",
	$one, $max, $min, $max - $min
	if $opt{verbose};
}

sub annotate { # use -r output to add reading schedule into given files unless there
    open FILE, $opt{a} or die $!;
    my $last = '{ Genesis Chapter 1 }';
    my %date;
    while (<FILE>) {
	/\s*(\w+\s+\d+)\s+(\{ .* Chapter \d+ \})/ or next;
	$date{$last} = $1;
	$last = $2;
    }

    my $tmp = ".tmp$$";
    for my $file (@ARGV) {
	open FILE, $file or die $!;
	open OUT, '>', $tmp or die $!;
	my $changed = 0;
	while (<FILE>) {
	    print OUT and next if /\*\*\*$/;
	    /(\{ .* Chapter \d+ \})/ and
		$date{$1} and
		s/(\{ .* Chapter \d+ \})/$1\t*** $date{$1} ***/ and
		$changed = 1;
	    print OUT;
	}
	close OUT or die $!;
	$changed
	    ? (rename $tmp, $file or die $!)
	    : (unlink $tmp or die $!);
    }
}
