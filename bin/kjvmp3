#!/usr/bin/perl

# KVJ audio player for emacs kjv-mode, by twitham@sbcglobal.net

# Can also now generate reading plans and .lrc lyric files!

# symlink this to the path of your 1189 *.mp3 bible chapters
my $cache = "$ENV{HOME}/.kjv";

use warnings;
use strict;
use Getopt::Long;
use Lingua::EN::Syllable;
use Time::Local;
use POSIX qw(strftime);
use File::Basename;
use Statistics::Descriptive;

my %opt = (mp3 => $cache);	# defaults

GetOptions(\%opt, qw(mp3|m=s lyric|l kjv|t=s verbose|v words|w n|dry
read|r=i annotate|a file|f=s check|c syllable|s bookmark|b))
    or die "usage: $0 [options] | '<book> Chapter <num>'
-m | --mp3	location of mp3 files (. || $opt{mp3})
-f | --file <file>	read the input from file, required for filters:
-c | --check	check the chapter to file map
-s | --syllable measure the words and syllables in the text
-r | --read = N	generate daily reading schedule for N days
-a | annotate	annotate reading schedule into listed files
-b | --bookmark	generate monthly bookmarks of reading schedule
-l | --lyric	generate 1189 .lrc lyric files
-v | --verbose	show syllables per line with -l, reading stats with -r
-w | --words	show syllables per word with -l
-n | --dry	don't write .lrc with -l, useful with -v
";
$opt{check} and $opt{lyric} = 1;
$opt{syllable} and $opt{lyric} = 1;

if (grep / Chapter /, @ARGV) {
    chdir $cache or
	die "please symlink dir of *.mp3 to $cache: $!";
} else {
    $opt{file} and -f $opt{file} and -s $opt{file} or
	die "-f input file required, see Makefile\n";
}

# hack!!! file naming convention indicates artist
my $who = -f '66_Revelation022.mp3' ? 'dw' # Dan Wagner
    : -f '66_Revelation_22.mp3' ? 'sj'	   # Stephen Johnston
    : -f 'Revelations 22.mp3' ? 'as'	   # Alexander Scourby
    : '??';

# Fix Pss 145 by ending time before the included Pss 146:1-8
# Fix Nah 3 by ending time after the missing Nah 3:17-19
my %fixlen = $who eq 'dw' ? (
    'Psalms 145' => ': 0:02:19', # exiftool -duration
    'Nahum 3' => ': 0:03:20',
    )
    : ();
	   
binmode STDOUT, ":encoding(UTF-8)";

opendir DIR, '.' or die $!;
my @mp3 = sort grep /\.mp3$/, readdir DIR;
closedir DIR;

if ($opt{lyric}) {		# generate lyric files for mythmusic!

    &lyrics;

} elsif ($opt{read}) {	  # generate time-based daily reading schedule

    &readplan;

} elsif ($opt{annotate}) {	# add reading schedule to each file

    &annotate;

} elsif ($opt{bookmark}) {	# add reading schedule to each file

    &bookmarks;

} elsif (@ARGV and $ARGV[0] =~ /(.+) Chapter (\d+)/) { # original purpose: audio player

    &play($1, $2);

}

sub file {			# book/chapter -> .mp3 filename
    my($book, $chapter) = @_;
    $book =~ s/ /_/g;
    $book =~ s/^III_/3/ or $book =~ s/^II_/2/ or  $book =~ s/^I_/1/;
    $book =~ s/_of_John//;
    my $chap = sprintf "%s%03d", $book, $chapter; # DW == default
    if ($who eq 'sj') {	    # tweaks to match zip filenames as/of 2022
	$book =~ s/Psalms/Psalm/;
	$book =~ s/Proverbs/Prov/;
	$book =~ s/Solomon/Soloman/; # files are misspelled...
	$book =~ s/Daniel/Daniell/;
	$book =~ s/Corinthians/Cor/; # ... or abbreviated
	$book =~ s/Galatians/Gal/;
	$book =~ s/Thessalonians/Thess/;
	my $n = $book =~ /Psalm/ ? 3 : 2;
	$chap = sprintf "%s_%0${n}d", $book, $chapter;
    } elsif ($who eq 'as') { # tweaks to match zip filenames as/of 2024
	$book =~ s/_/ /g;
	$book =~ s/^([123])(\S+)/$1 $2/;
	$book =~ s/Psalms/Psalm/;
	$book =~ s/(Revelation)\b/$1s/;
	for my $n (3, 2, 1) {
	    my $file = sprintf "%s %0${n}d.mp3", $book, $chapter;
	    # warn "checking for $file";
	    -f $file and return $file;
	}
	-f "$book.mp3" and return "$book.mp3"; # 1 chapter books
	return 0;
    }
    my $file = (grep /$chap.mp3/, @mp3)[0] || (grep /$book.mp3/, @mp3)[0] || 0;
    return $file;
}

sub play {
    my $file = file(@_);
    $file or return;
    system qw/mplayer -quiet/, $file;
}

# This measures the text for distributing the correct portion of time
# of the audio to each line.  Initialy I measured bytes, then improved
# to words, and finally to syllables.

sub len {			# return the length of the text
    my $syb = my $word = my $num = 0;
    for my $line (@_) {

	my $len = 0;
	$line =~ /^(\S+ \d+:\d+:)?\s*(.*)/; # ignore chapter/verse leader

	(my $text = $2) =~ s/\s+\*\*.*//; # ignore reading schedule

	$text =~ s/^\W+//;
	my $words = split /\W+/, $text;

	$text =~ s/([;:,])/ PAUSE /g; # punctuation pauses

	$text =~ s/([{}?.])/ STOP STOP /g; # sentence pauses

	$text =~ s/\W+/ /g; # strip italics and quotes and break hyphens

	$text =~ s/^\s*$/ P /;	# blank lines need a unique timestamp

	for my $word (split /\s+/, $text) {
	    $word =~ /^\w+$/ or next;
	    my $one = syllable $word;
	    print " $word=$one" if $opt{words};
	    $len += $one;
	}
	print "\n" if $opt{words};
	print "$words\t$len\t$line";
	$syb += $len;
	$word += $words;
	$num++;
    }
    print qq'$word\t$syb\t\t\t*** ($word words, ',
	qq'$syb reading syllables in $num lines)\n';
    return $syb;
}

my %next;			# {chapter} = next chapter
sub lyrics {
    my @line;
    open FILE, '<:encoding(UTF-8)', $opt{file} or die "$opt{file}: $!";
    my $last = '';
    while (<FILE>) {		# AS needs to find book ends
	if (/\{ (.+ Chapter \d+) \}/) {
	    $next{$last} = $1;
	    $last = $1;
	}
    }
    $next{$last} = 'The End';
    seek FILE, 0, 0;		# start over
    while (<FILE>) {
	next if / mode: kjv /;	# skip header
	s/\(KJV\)//;		# skip footer
	if (@line > 5 and /\{ (The Book of .+|.+ Chapter \d+) \}/) {
	    &lyric(\@line);
	    @line = ();
	}
	push @line, $_;
    }
    &lyric(\@line);
}

# measure the words and syllables in the text
sub measure {
    my($lineref) = @_;
    my $len = len(@$lineref);
    return 1;
}

# See https://en.wikipedia.org/wiki/LRC_(file_format)
sub lyric {
    my($lineref) = @_;
    return measure($lineref)
	if $opt{syllable};
    my $head = (grep { /\{ .+ Chapter \d+ \}/ } @$lineref)[0] or return;
    $head =~ /\{ (.+) Chapter (\d+) \}/ or return;
    my($book, $chap) = ($1, $2);
    my $file = file($book, $chap);
    $file or print "no file for $head\n" and return;
    (my $out = $file) =~ s/.mp3/.lrc/;
    $opt{check} and print "$book $chap -> $file\n" and return;

    # input file must be pre measured by now
    my $tail = (grep { /syllables/ } @$lineref)[0] or return;
    my($words, $len) = split "\t", $tail or return;
    $len or return;

    my $duration = $fixlen{"$book $chap"} || `exiftool -duration '$file'`;
    my($h, $m, $s) = ($duration =~ /: (\d+):(\d+):(\d+)/);
    defined $s or ($h, $m, $s) = ($duration =~ /: ()()(\d+\.\d+) s/);
    defined $s or warn "unknown seconds in $file\n" and return;
    $duration = ($h || 0) * 3600 + ($m || 0) * 60 + $s;
    if ($who eq 'as') {	# book closing statement runs longer past the text
	$duration -=
	    $next{"$book Chapter $chap"} =~ /^$book / ? 1 : 7;
    } else {
	$duration -= 3;	       # seconds of silence on the end of file
    }
    my $per = $duration / $len;	# seconds per reading syllable of text
    my $t = 0;
    open OUT, '>:encoding(UTF-8)', ($opt{n} ? '/dev/null' : $out) or die $!;
    for my $line (@$lineref) {
	my $min = int($t / 60);
	my $sec = $t - $min * 60;
	$line =~ s/^(\d+)\t(\d+)\t// or next; # words, syllables
	my $len = $2;			      # syllables
	my $this = sprintf "[%02d:%05.02f]$line", $min, $sec;
	print OUT $this;
	print "$len\t$this" if $opt{verbose};
	$t += $len * $per;
    }
    printf "%4d seconds in %4d lines @ %5.2f syllable/s in $out\n",
	$duration, scalar @$lineref, $len / $duration;
    return 1;
}

{
    my $syb = 0;	  # total syllables
    my %syb;		  # {chapter} = syllables before this point
    my @chap;
sub readplan {		  # generate reading schedule from kjv-syb.tmp
    my $chap;
    open FILE, $opt{file} or die "$opt{file}: $!";
    while (<FILE>) {		# words syllables text
	m/(\{ (\w.+\d) \})/ and $chap = $1;
	m/^(\d+)\t(\d+)\t.*syllables.*in/ or next;
	push @chap, $2;
	$syb += $2;		# running total
	$syb{$chap} = $syb;	# syllables to this chapter end
    }
    $syb{'{ The End Chapter 0 }'} = $syb;

    my $file = "$opt{file}.txt"; # best factor cache
    my %frac;
    if (open FILE, $file) {
	while (<FILE>) {
	    my($days, $rest) = split "\t", $_, 2;
	    $frac{$days} = $rest if $days =~ /\d+/;
	}
    }
    my $good = 0;		# best multiplier of minimum stddev
    if (my $tmp = $frac{$opt{read}}) {
	$tmp =~ /^(\S+)/ and $good = $1;

    } else {		 # find goal factor that yields minimum stddev
	my $min = 99999;
	open FILE, '>', $file or die "can't write $file: $!";
	print "finding chapter breaks of minimum stddev for $opt{read} days\n";
	for (my $try = 0; $try < 0.25; $try += 0.01) {
	    my $stddev = &tryplan($try, 1);
	    my $found = '';
	    $min = $stddev and $good = $try and $found = "\t<<<<<"
		if $stddev < $min;
	    print "$try\t$stddev$found\n";
	}
	my $zero = &tryplan(0, 1); # aim for mean syllables only
	my $one = &tryplan(1, 1);  # aim for nearest break only
	$frac{$opt{read}} = join("\t", $good, int($syb / $opt{read} + 0.5),
				 $min, $zero, $one) . "\n";
	print FILE join("\t", qw/days factor mean stddev 0 1/),
	    "\t($syb syllables)\n";
	for (sort {$a <=> $b} keys %frac) {
	    print FILE "$_\t$frac{$_}";
	}
	close FILE or die $!;
    }
    &tryplan($good);
}
sub tryplan {
    my($frac, $preview) = @_;
    my $this = my $last = 0;
    my $date = timelocal(0, 0, 12, 1, 0, 3); # 1973 - 1975 no leap years
    my $days = $opt{read} ? $opt{read} : 365;
    my $one = $syb / $days;	# syllable per day
    my $i = my $delta = my $max = 0;
    my $min = 999999;
    my $stat = Statistics::Descriptive::Full->new();
    for (my $time = $one; $time < $syb + $one / 2; $time += $one) {

	# daily reading goal, but move toward staying on-time via delta
	my $goal = $last + $one;
	$goal -= $frac * $delta;
	my $chap = (sort { abs($syb{$a} - $goal) <=>
			       abs($syb{$b} - $goal) } keys %syb)[0];
	my $this = $syb{$chap};
	$delta = $this - $time;	 # offset from perfect time
	my $len = $this - $last; # today's reading time
	$last = $this;
	$max = $len if $len > $max;
	$min = $len if $len < $min;

	my $ts = strftime "%10B %e", localtime $date;
	if ($preview) {
	    $stat->add_data($len);
	} else {
	    my $num;
	    my @me;
	    do {
		push @me, shift @chap;
		$num = 0;
		map { $num += $_ } @me;
	    } while ($num < $len);
	    printf "%d\t%s\t%d\t%s\t@me\n", $len, $ts, $delta, $chap;
	}
	$date += 24 * 60 * 60;
    }
    if ($preview) {
	return $stat->standard_deviation() || 0;
    }
    printf "(goal=%.0f reading syllables for $days days, "
	. "range %d-%d=%d, +/- delta)\n",
	$one, $max, $min, $max - $min
	if $opt{verbose};
}
}

sub annotate { # use -r output to add reading schedule into given files
    open FILE, $opt{file} or die "$opt{file}: $!";
    my @chap;
    while (<FILE>) {		# -r reading plan
	/ Chapter \d+ \}\t(.+)$/ or next;
	push @chap, [ split ' ', $1 ];

    }
    my $tmp = ".tmp$$";
    for my $file (@ARGV) {	# kjv.txt [ kjv.syb.txt ]
	my $date = timelocal(0, 0, 12, 1, 0, 3); # 1973 - 1975 no leap years
	open FILE, $file or die $!;
	open OUT, '>', $tmp or die $!;
	my $day = 0;		# day index
	my $num = 0;		# numerator
	while (<FILE>) {
	    if (s/(\{ .* Chapter \d+ \}).*/$1/) {
		my $n = 40 - length($1);
		my $s = " " x ($n % 8);
		$s .= "\t" x ($n / 8);
		my $ts = strftime "%B %e", localtime $date;
		my $chaps = @{$chap[$day]};
		$num++;
		s{(\{ .* Chapter \d+ \}).*}
		{$1$s** $ts $num/$chaps **};
		if ($num >= $chaps) {
		    $day++;
		    $num = 0;
		    $date += 24 * 60 * 60;
		}
	    }
	    print OUT;
	}
	close OUT or die $!;
	rename $tmp, $file or die $!;
    }
}

sub bookmarks {		 # use -r output to generate monthly bookmarks
    open FILE, $opt{file} or die "$opt{file}: $!";
    my $head = "\n\nBy Date: - Read through:\n\n";
    my $foot = '';
    my %done;
    while (<FILE>) {		# -r reading plan
	s/\d+\t//;
	s/( of John)? Chapter\b//;
	/((\w+)\s+\d+).*\{ (.*) \}/ or next;
	$done{$2}++ or print "$foot$head";
	print "$1 - $3\n";
	$foot = "\nRead the Bible in a Year!\n"
	    . chr(12) . "\n";
    }
    chomp $foot;
    print $foot;
}
