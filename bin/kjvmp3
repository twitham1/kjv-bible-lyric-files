#!/usr/bin/perl

# KVJ audio player for emacs kjv-mode, by twitham@sbcglobal.net

# Can also now generate reading plans and .lrc lyric files!

use warnings;
use strict;
use Getopt::Long;
use Lingua::EN::Syllable;
use Time::Local;
use POSIX qw(strftime);
use File::Basename;
use Statistics::Descriptive;

# symlink this to the path of your 1189 *.mp3 bible chapters
my $cache = "$ENV{HOME}/.kjv";
my %opt = (mp3 => $cache);	# defaults
my $cfile = './.kjvmp3.pl';	# configuration file

# these can be overridden in a $cfile configuration file
my $def = {
    # given a book and chapter, return its mp3 filename
    mp3file => sub {
	my($book, $chap) = @_;
	$book =~ s/ /-/g;
	return "$book-$chap.mp3";
    },
    # length of the audio in exiftool -duration
    length => sub {
	my($sec, $chap, $next) = @_;
	return $sec - 3;	# skip 3 seconds of end silence
    },
    # file to read for text/audio syncronization points
    syncfile => $cfile,
};
my $cfg = require $cfile if -f $cfile; # must return a config hash
my $conf = {};			       # cfg || def configuration
for (keys %$def) {
    $conf->{$_} = $cfg->{$_} || $def->{$_};
}

GetOptions(\%opt, qw(mp3|m=s lyric|l kjv|t=s verbose|v words|w n|dry
read|r=i annotate|a file|f=s check|c syllable|s bookmark|b))
    or die "usage: $0 [options] | '<book> Chapter <num>'
-m | --mp3	location of mp3 files (. || $opt{mp3})
-f | --file <file>	read the input from file, required for filters:
-c | --check	check the chapter to file map
-s | --syllable measure the words and syllables in the text
-r | --read = N	generate daily reading schedule for N days
-a | --annotate	annotate reading schedule into listed files
-b | --bookmark	generate monthly bookmarks of reading schedule
-l | --lyric	generate 1189 .lrc lyric files
-v | --verbose	show syllables per line with -l, reading stats with -r
-w | --words	show syllables per word with -l
-n | --dry	don't write .lrc with -l, useful with -v
";
$opt{check} and $opt{lyric} = 1;
$opt{syllable} and $opt{lyric} = 1;

if (grep / Chapter /, @ARGV) {
    chdir $cache or
	die "please symlink dir of *.mp3 to $cache: $!";
} else {
    $opt{file} and -f $opt{file} and -s $opt{file} or
	die "-f input file required, see Makefile\n";
}

binmode STDOUT, ":encoding(UTF-8)";

opendir DIR, '.' or die $!;
our @mp3 = sort grep /\.mp3$/, readdir DIR;
closedir DIR;

if ($opt{lyric}) {		# generate lyric files for mythmusic!

    &lyrics;

} elsif ($opt{read}) {	  # generate time-based daily reading schedule

    &readplan;

} elsif ($opt{annotate}) {	# add reading schedule to each file

    &annotate;

} elsif ($opt{bookmark}) {	# generate bookmarks

    &bookmarks;

# original purpose: audio player
} elsif (@ARGV and $ARGV[0] =~ /(.+) Chapter (\d+)/) {

    &play($1, $2);

}

sub file {			# book/chapter -> .mp3 filename
    my($book, $chapter) = @_;
    return $conf->{mp3file}(@_);
}

sub play {
    my $file = file(@_);
    $file or return;
    system qw/mplayer -quiet/, $file;
}

# This measures the text for distributing the correct portion of time
# of the audio to each line.  Initialy I measured bytes, then improved
# to words, and finally to syllables.

my %seen;
sub len {			# return the length of the text
    my $syb = my $word = my $num = 0;
    my $chap;
    for my $line (@_) {
	warn $line if $line =~ /^(\*\*.*Chapter)/ and !$seen{$1}++;

	my $len = 0;
	$line =~ /^((\S+ \d+):\d+:)?\s*(.*)/; # ignore chapter/verse leader
	$2 and $chap = $2;
	(my $text = $3) =~ s/\s+\*\*.*//; # ignore reading schedule

	$text =~ s/^\W+//;
	my $words = split /\W+/, $text;

	$text =~ s/[;:,]/ PAUSE /g; # punctuation pauses

	$text =~ s/[\}?!.]/ STOP STOP /g; # sentence pauses

	$text =~ s/\W+/ /g; # strip italics and quotes and break hyphens

	$text =~ s/^\s*$/ P /;	# blank lines need a unique timestamp

	for my $word (split /\s+/, $text) {
	    $word =~ /^\w+$/ or next;
	    my $one = syllable $word;
	    print " $word=$one" if $opt{words};
	    $len += $one;
	}
	print "\n" if $opt{words};
	print "$words\t$len\t$line";
	$syb += $len;
	$word += $words;
	$num++;
    }
    print "$word\t$syb\t$chap\t\t*** ($syb syllables, ",
	"$word words, $num lines)\n";
    return $syb;
}

my %next;			# {chapter} = next chapter
sub lyrics {
    &readsyncs;			# optional text/audio sync points
    my @line;
    open FILE, '<:encoding(UTF-8)', $opt{file} or die "$opt{file}: $!";
    my $last = '';
    while (<FILE>) {		# AS needs to find book ends
	if (/\{ (.+ Chapter \d+) \}/) {
	    $next{$last} = $1;
	    $last = $1;
	}
    }
    $next{$last} = 'The End';
    seek FILE, 0, 0;		# start over
    my $search = $ARGV[0] || undef; # search for given chapter?
    while (<FILE>) {
	$search and m/$search/ and $search = 0;
	$search and next;
	next if / mode: kjv /;	# skip header
	s/\(KJV\)//;		# skip footer
	if (@line > 5 and /\{ (The Book of .+|.+ Chapter \d+) \}/) {
	    &lyric(\@line);
	    @line = ();
	    defined $search and last; # just one for search
	}
	push @line, $_;
    }
    &lyric(\@line);
}

# measure the words and syllables in the text
sub measure {
    my($lineref) = @_;
    my $len = len(@$lineref);
    return 1;
}

sub replace_file {	      # replace a file only if content changed
    my($src, $dst) = @_;
    $src and $dst and -f $src or
	warn "source file $src must exist and destination given"
	and return 0;
    my $fh; local $_;
    my $before = '';
    if (-f $dst and open $fh, $dst)  {
	$before .= $_ while (<$fh>);
	close $fh or die $!;
    }
    my $after = '';
    open $fh, $src or die "can't read $src: $!\n";
    $after .= $_ while (<$fh>);
    close $fh or die $!;

    $before eq $after and return 1;

    open $fh, '>', $dst or die "can't write $dst: $!\n";
    print $fh $after;
    close $fh or die $!;
    return 1;
}

sub readsyncs {			# read optional text/audio sync points
    my $syncs = {};
    if (open my $fh, $conf->{syncfile}) {
	my $book;
	while (<$fh>) {
	    s/\s*#.*//;
	    m/^(\w+)$/ and $book = $1;
	    m/^__END__$/ and $syncs = {}; # start over
	    m/(\d+)[.:](\d+)\s+(\d+)[.:](\d+)/
		and $syncs->{"$book $1"}{$2}{sec} = $3 * 60 + $4;
	}
	close $fh or die $!;
    }
    $conf->{syncs} = $syncs;
}

sub rates {			# find rate per sync section
    my($abbr, $syb, $dur, $lineref) = @_;
    my $s = $conf->{syncs}{$abbr};
    $s->{0} = {sec => 0, syb => 0};	     # beginning second
    $s->{9999} = {sec => $dur, syb => $syb}; # last second
    my $prev = my $verse = my $syllables = 0;
    for my $line (@$lineref) {
	my($words, $sybs, $v) = split "\t", $line;
	if (($line =~ m/syllables,/ and $verse = 9999
	     or $v =~ m/.*\d+:(\d+):/ and $verse = $1)
	    and defined $s->{$verse}) {
	    $s->{$verse}{syb} = 0; # sybs past this point
	    $s->{$prev}{per} = $syllables /
		($s->{$verse}{sec} - $s->{$prev}{sec});
	    $prev = $verse;
	    $syllables = 0;	# sybs per section
	}
	$syllables += $sybs;
	$s->{$prev}{syb} += $sybs;
    }
    return $s;
}

# See https://en.wikipedia.org/wiki/LRC_(file_format)
sub lyric {
    my($lineref) = @_;
    return measure($lineref)
	if $opt{syllable};
    my $head = (grep { /\{ .+ Chapter \d+ \}/ } @$lineref)[0] or return;
    $head =~ /\{ (.+) Chapter (\d+) \}/ or return;
    my($book, $chap) = ($1, $2);
    my $file = file($book, $chap);
    $file or print "no file for $head\n" and return;
    (my $out = $file) =~ s/.mp3/.lrc/;
    $opt{check} and print "$book $chap -> $file\n" and return;

    # input file must be pre measured by now
    my $tail = (grep { /syllables/ } @$lineref)[0] or return;
    my($words, $len, $abbr) = split "\t", $tail or return;
    $len or return;

    chomp(my $duration = `exiftool -duration '$file'`);
    my($h, $m, $s) = ($duration =~ /: (\d+):(\d+):(\d+)/);
    defined $s or ($h, $m, $s) = ($duration =~ /: ()()(\d+\.\d+) s/);
    defined $s or warn "unknown seconds in $file\n" and return;
    $duration = ($h || 0) * 3600 + ($m || 0) * 60 + $s;
    $duration = $conf->{length}($duration, "$book Chapter $chap",
				$next{"$book Chapter $chap"});

    my $rate = rates($abbr, $len, $duration, $lineref);
    my $num = keys(%$rate) - 2;	# syncs

    my $t = my $verse = 0;	# verse that starts rate section
    my @rate = (sprintf('%.2f', $rate->{0}{per})); # rates used
    open OUT, '>:encoding(UTF-8)', ($opt{n} ? '/dev/null' : "$out~")
	or die $!;
    for my $line (@$lineref) {	# lines of chapter
	$line =~ m/.*\d+:(\d+):/
	    and (defined $rate->{$1}) # begin new rate section
	    and $verse = $1
	    and $t = $rate->{$1}{sec}
	    and push @rate, sprintf('%.2f', $rate->{$1}{per})
	    and $line =~ s/:(\d+):/.$1./;     # sync marker
	$line =~ s/^(\d+)\t(\d+)\t// or next; # words, syllables
	my $sybs = $2;			      # syllables
	$num and $line =~ s/( syllables,.*)./$1, $num syncs)/;
	my $min = int($t / 60);
	my $sec = $t - $min * 60;
	my $this = sprintf "[%02d:%05.02f]$line", $min, $sec;
	print OUT $this;
	print "$sybs\t$rate->{$verse}{per}\t$this" if $opt{verbose};
	$t += $sybs / $rate->{$verse}{per};
    }
    close OUT or die $!;
    $opt{n} or (replace_file("$out~", $out) and unlink "$out~");
    printf "%4d secs of %4d sybs in %4d lines in $out, syb/s: @rate\n",
	$duration, $len, scalar @$lineref - 1; # footer doesn't count
    warn "Suspicious reading rate in $out: @rate\n"
	if grep { $_ < 2 || $_ > 7 } @rate;
    return 1;
}

{
    my $syb = 0;	  # total syllables
    my %syb;		  # {chapter} = syllables before this point
    my @chap;
sub readplan {		  # generate reading schedule from kjv-syb.tmp
    my $chap;
    open FILE, $opt{file} or die "$opt{file}: $!";
    while (<FILE>) {		# words syllables text
	m/(\{ (\w.+\d) \})/ and $chap = $1;
	m/^(\d+)\t(\d+)\t.*syllables\b/ or next;
	push @chap, $2;
	$syb += $2;		# running total
	$syb{$chap} = $syb;	# syllables to this chapter end
    }
    $syb{'{ The End Chapter 0 }'} = $syb;

    my $file = "$opt{file}.txt"; # best factor cache
    my %frac;
    if (open FILE, $file) {
	while (<FILE>) {
	    my($days, $rest) = split "\t", $_, 2;
	    $frac{$days} = $rest if $days =~ /\d+/;
	}
    }
    my $good = 0;		# best multiplier of minimum stddev
    if (my $tmp = $frac{$opt{read}}) {
	$tmp =~ /^(\S+)/ and $good = $1;

    } else {		 # find goal factor that yields minimum stddev
	my $min = 99999;
	open FILE, '>', $file or die "can't write $file: $!";
	warn "finding chapter breaks of minimum stddev for $opt{read} days\n";
	for (my $try = 0; $try < 0.25; $try += 0.01) {
	    my $stddev = &tryplan($try, 1);
	    my $found = '';
	    $min = $stddev and $good = $try and $found = "\t<<<<<"
		if $stddev < $min;
	    warn "$try\t$stddev$found\n";
	}
	my $zero = &tryplan(0, 1); # aim for mean syllables only
	my $one = &tryplan(1, 1);  # aim for nearest break only
	$frac{$opt{read}} = join("\t", $good, int($syb / $opt{read} + 0.5),
				 $min, $zero, $one) . "\n";
	print FILE join("\t", qw/days factor mean stddev 0 1/),
	    "\t($syb syllables)\n";
	for (sort {$a <=> $b} keys %frac) {
	    print FILE "$_\t$frac{$_}";
	}
	close FILE or die $!;
    }
    &tryplan($good);
}
sub tryplan {
    my($frac, $preview) = @_;
    my $this = my $last = 0;
    my $date = timelocal(0, 0, 12, 1, 0, 3); # 1973 - 1975 no leap years
    my $days = $opt{read} ? $opt{read} : 365;
    my $one = $syb / $days;	# syllable per day
    my $i = my $delta = my $max = 0;
    my $min = 999999;
    my $stat = Statistics::Descriptive::Full->new();
    for (my $time = $one; $time < $syb + $one / 2; $time += $one) {

	# daily reading goal, but move toward staying on-time via delta
	my $goal = $last + $one;
	$goal -= $frac * $delta;
	my $chap = (sort { abs($syb{$a} - $goal) <=>
			       abs($syb{$b} - $goal) } keys %syb)[0];
	my $this = $syb{$chap};
	$delta = $this - $time;	 # offset from perfect time
	my $len = $this - $last; # today's reading time
	$last = $this;
	$max = $len if $len > $max;
	$min = $len if $len < $min;

	my $ts = strftime "%10B %e", localtime $date;
	if ($preview) {
	    $stat->add_data($len);
	} else {
	    my $num;
	    my @me;
	    do {
		push @me, shift @chap;
		$num = 0;
		map { $num += $_ } @me;
	    } while ($num < $len);
	    printf "%d\t%s\t%.0f\t%s\t@me\n", $len, $ts, $delta, $chap;
	}
	$date += 24 * 60 * 60;
    }
    if ($preview) {
	return $stat->standard_deviation() || 0;
    }
    printf "(goal=%.0f reading syllables for $days days, "
	. "range %d-%d=%d, +/- delta)\n",
	$one, $max, $min, $max - $min
	if $opt{verbose};
}
}

sub annotate { # use -r output to add reading schedule into given files
    open FILE, $opt{file} or die "$opt{file}: $!";
    my @chap;
    while (<FILE>) {		# -r reading plan
	/ Chapter \d+ \}\t(.+)$/ or next;
	push @chap, [ split ' ', $1 ];

    }
    my $tmp = ".tmp$$";
    for my $file (@ARGV) {	# kjv.txt [ kjv.syb.txt ]
	my $date = timelocal(0, 0, 12, 1, 0, 3); # 1973 - 1975 no leap years
	open FILE, $file or die $!;
	open OUT, '>', $tmp or die $!;
	my $day = 0;		# day index
	my $num = 0;		# numerator
	while (<FILE>) {
	    if (s/(\{ .* Chapter \d+ \}).*/$1/) {
		my $n = 40 - length($1);
		my $s = " " x ($n % 8);
		$s .= "\t" x ($n / 8);
		my $ts = strftime "%B %e", localtime $date;
		my $chaps = @{$chap[$day]};
		$num++;
		s{(\{ .* Chapter \d+ \}).*}
		{$1$s** $ts $num/$chaps **};
		if ($num >= $chaps) {
		    $day++;
		    $num = 0;
		    $date += 24 * 60 * 60;
		}
	    }
	    print OUT;
	}
	close OUT or die $!;
	rename $tmp, $file or die $!;
    }
}

sub bookmarks {		 # use -r output to generate monthly bookmarks
    open FILE, $opt{file} or die "$opt{file}: $!";
    my $head = "\n\nBy Date: - Read through:\n\n";
    my $foot = '';
    my %done;
    while (<FILE>) {		# -r reading plan
	s/\d+\t//;
	s/( of John)? Chapter\b//;
	/((\w+)\s+\d+).*\{ (.*) \}/ or next;
	$done{$2}++ or print "$foot$head";
	print "$1 - $3\n";
	$foot = "\nRead the Bible in a Year!\n"
	    . chr(12) . "\n";
    }
    chomp $foot;
    print $foot;
}
